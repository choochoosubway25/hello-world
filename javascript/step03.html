<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
        // 4. var, let, const
        /*
            전에 봤던것처럼 var 은 현대 프로그래밍 언어의 변수와는 
            생각보다 많은 괴리를 가지고 있다.
            그래서 ES6 에서 let, const가 추가되었고,
            신규로 자바스크립트를 짤 경우 var은 지양하고,
            원시형 자료형에서 변수는 let, 원시형 자료형의 고정값과 참조형은
            const로 선언하도록 권고하고 있다.
        */
        /*
        원시형 자료형과 참조형 자료형의 차이 : 
        원시형 자료형은 변수 하나에 값이 하나만 저장이 됨
        참조형 자료형은 변수 하나에 값이 여러개 저장이 됨
        */
        /*
            기존의 var vs 신규의 let:
            var: 이중선언 가능 vs let : 이중선언 불가능
            var: 호이스팅 가능 vs let : 호이스팅 불가능
            var: 함수단위 유효 vs let : 블록단위(들여쓰기 기준) 유효
            ex)
            var xi = 'pingping';
            console.log(xi); // pingping

            if(true) {
                var xi = 'pooh';
                console.log(xi); // pooh
            }

            console.log(xi) // pooh

            let xi = 'pingping';
            console.log(xi) // pingping

            if(true) {
                // xi를 if구문 안에서 재선언 했을 경우 재선언의 범위는 
                // if문 내로 제한된다.
                let xi = 'pooh';
                console.log(xi) // pooh
            }
            // if문 내의 재선언은 여기에 영향을 끼치지 않는다.
            console.log(xi) // pingping
        */
        /* 참고
            자료형의 종류 : 원시형, 참조형
            1) 원시형의 종류 
            number type / string type / boolean type /
            undefined type / null type
            2) 참조형의 종류
            object type / array type(object) / function type
        */
        /*
        원시형에서 const는 상수로 동작 -> 재할당을 할 경우 오류 발생
        ex)
        const pooh = 0;
        pooh = 1;
        // Uncaught TypeError: Assignment to constant variable.

        참조형일때는 const로 선언하는 것을 추천

        */
        /*
            중요하니 다시한번 정리:
            ES6 에서는 (신규로 자바스크립트를 짤 경우) var은 지양하고,
            원시형 자료형에서 변수는 let, 상수는 const 선언
            참조형 자료형은 const로 선언하도록 권고하고 있다.
        */

        let a1 = 1000;
        /* //Uncaught SyntaxError: Identifier 'a1' has already been declared.
        let a1 = 2000; //이중선언금지 */
        console.log(a1);

        /* console.log(a2); // 에러 발생
        //Uncaught ReferenceError: Cannot access 'a2' before initialization. */
        let a2 = 2000; // 변수 호이스팅이 안됨, var 로 바꾸면 에러 없이 동작 잘됨.
        console.log(a2);

        const a3 = 3000; // 원시타입일때 const로 선언하면 상수화
                         // 되기 때문에 값을 변경할 수 없음.
        //Uncaught TypeError: Assignment to constant variable.
        /* a3 = 4000; */
        console.log(a3);

        const a4 = [10,20,30]; // 배열은 참조형 변수
        a4.push(40); // a4 라는 틀 안에서 참조하는 변수들의 상태 또는 값이 변하기 때문에 별 무리가 없다.
        console.log(a4);

        //Uncaught TypeError: Assignment to constant variable
        /* a4 = [100,200,300];
        console.log(a4) // 이럴 경우, a4를 새로운 배열로 재할당 하는것이므로
                        // 재할당 오류가 발생한다.
                        // const 선언이 참조변수 일때 재할당을 하게 되면 에러발생 */

        let a = 10;
        {
            console.log(a) //Uncaught ReferenceError: Cannot access 'a2' before initialization.
            let a = 20; // 이렇게 새로운 내부 블록에서 a를 다시 선언하면 
                        // 여기에서의 a는 블록 바깥의 a와 다른 변수로 인식
                        // 그런데 여기선 a를 명령 후에 호이스팅 선언을 했으므로
                        // 레퍼런스 에러가 발생한다고 볼 수 있다.
        }
    </script>
    <title>let, const</title>
</head>
<body>
    
</body>
</html>